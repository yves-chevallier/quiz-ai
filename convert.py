#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Convert a quiz described in YAML into a LaTeX exam using the `exam` class
(and the same look-and-feel as in the provided example).

Usage:
    python yaml_to_exam_tex.py input.yml -o output.tex

Notes:
- Supports question types: multiple_choice, fill_in_the_blank, multiple_fill_in, short_answer.
- In multiple_choice, `correct_choice` may be a 1-based int or a list of 1-based ints.
- In fill_in_the_blank you can either provide a free-form `question` string with
  placeholders like `{{answer}}` to turn them into `\fillin[answer]`, or an
  `expressions` list where each item is a string (potentially with `{{answer}}`).
- In multiple_fill_in, use `expressions: [ ["<prompt>", "<answer>"], ... ]`.
- For short_answer, the script draws lines with `\fillwithlines{1cm}`; if an
  `answer` is present, it is included as a LaTeX comment for the instructor.

This script purposefully avoids external templating engines; everything is
rendered with Python for portability.
"""

import argparse
import re
from pathlib import Path
from typing import Any, Dict, Iterable, List, Union

try:
    import yaml  # PyYAML
except Exception as e:
    raise SystemExit("This script requires PyYAML. Try: pip install pyyaml")


# ------------------------- Utilities -------------------------
LATEX_SPECIALS = {
    "\\": r"\textbackslash{}",
    "&": r"\&",
    "%": r"\%",
    "$": r"\$",
    "#": r"\#",
    "_": r"\_",
    "{": r"\{",
    "}": r"\}",
    "~": r"\textasciitilde{}",
    "^": r"\textasciicircum{}",
}


def escape_latex(text: str) -> str:
    """Escape LaTeX specials in normal text. Leave code/math blocks alone upstream."""
    return "".join(LATEX_SPECIALS.get(ch, ch) for ch in text)


def convert_inline_code(s: str) -> str:
    """Convert inline `code` to \lstinline|code|.
    Avoid touching triple backtick blocks (handled elsewhere).
    """
    def repl(m: re.Match) -> str:
        code = m.group(1)
        # choose a delimiter not contained in code; fallback to |
        for delim in "|/!;:^~#@" :
            if delim not in code:
                return f"\\lstinline{delim}{code}{delim}"
        return f"\\lstinline|{code}|"

    return re.sub(r"`([^`]+)`", repl, s)


def convert_fenced_code(s: str) -> str:
    """Convert fenced code blocks ```lang ... ``` to lstlisting.
    Keeps math $$...$$ intact.
    """
    pattern = re.compile(r"```([A-Za-z0-9_-]+)?\n(.*?)\n```", re.DOTALL)

    def repl(m: re.Match) -> str:
        lang = (m.group(1) or "").strip().lower()
        body = m.group(2)
        lang_opt = ""
        if lang in {"py", "python"}:
            lang_opt = "[language=Python]"
        elif lang in {"bash", "sh"}:
            lang_opt = "[language=bash]"
        # Escape nothing inside listings; it's verbatim
        return f"\\begin{{lstlisting}}{lang_opt}\n{body}\n\\end{{lstlisting}}"

    return pattern.sub(repl, s)


def replace_placeholders_with_fillin(s: str) -> str:
    """Replace {{answer}} with \fillin[answer]."""
    return re.sub(r"\{\{\s*(.*?)\s*\}\}", r"\\fillin[\\1]", s)


# ------------------------- Rendering -------------------------

PREAMBLE = r"""% AUTOGENERATED BY yaml_to_exam_tex.py
\documentclass[french,a4paper,addpoints,11pt]{exam}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{fontspec}
\usepackage{hexam}
\usepackage{bashful}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{everyshi}
\usepackage{xcolor}
\usepackage{etoolbox}
\usepackage{zref-savepos}
\usepackage{multicol}
\usepackage{listings}

\usetikzlibrary{calc}
\hypersetup{pdfborder={0 0 0}, colorlinks=false}

\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\setlength{\topsep}{0pt}

\pointsdroppedatright

% Listing style (minimal)
\lstset{basicstyle=\ttfamily\small, breaklines=true}

\renewcommand{\checkboxeshook}{%
  \settowidth{\leftmargin}{W.}
  \setlength{\topsep}{1em}
  \labelwidth\leftmargin\advance\labelwidth-\labelsep%
}
\renewcommand{\partshook}{\setlength{\itemsep}{1em}}

\definecolor{GridColor}{gray}{0.5}
\definecolor{FillWithDottedLinesColor}{gray}{0.5}

\thispagestyle{empty}

% Anchor-able question numbers (like in your example)
\makeatletter
\renewcommand{\questionlabel}{%
  \Hy@raisedlink{\hypertarget{Q\thequestion-anchor}{}}%
  \thequestion.
}
\makeatother
"""

COVER_TEMPLATE = r"""
\title{{title}\\ {subtitle}}
\author{{author}}
\department{{department}}
\school{{school}}
\date{{date}}

\begin{document}
\begin{coverpages}
    \maketitle
    \thispagestyle{empty}

    \vspace{0.1in}

    \fbox{\fbox{\parbox{5.5in}{
                \textbf{Consignes :}
                \vskip 1em%
                \begin{itemize}
{directives}
                \end{itemize}
            }}}
\end{coverpages}
\setcounter{page}{2}
\begin{questions}
"""

END_DOC = """
\end{questions}
\end{document}
"""


def render_directives(items: Iterable[str]) -> str:
    return "\n".join(f"                    \item {escape_latex(i)}" for i in items)


def maybe_multicols_open(n_choices: int) -> str:
    # Simple heuristic to improve layout
    if n_choices >= 6:
        return "\\begin{multicols}{2}\n"
    return ""


def maybe_multicols_close(n_choices: int) -> str:
    if n_choices >= 6:
        return "\\end{multicols}\n"
    return ""


def render_choices(choices: List[str], correct_spec: Union[int, List[int], None]) -> str:
    # Normalize correct indices to a set of 1-based positions
    correct: set[int] = set()
    if isinstance(correct_spec, int):
        correct = {correct_spec}
    elif isinstance(correct_spec, list):
        correct = {int(i) for i in correct_spec}

    lines = ["\\begin{checkboxes}"]
    for i, ch in enumerate(choices, start=1):
        text = ch
        text = convert_fenced_code(text)
        text = convert_inline_code(text)
        # Don't escape within listings; escape the rest lightly
        text = escape_latex(text)
        cmd = "\\CorrectChoice" if i in correct else "\\choice"
        lines.append(f"    {cmd} {text}")
    lines.append("\\end{checkboxes}")
    return "\n".join(lines)


def question_header(points: Any) -> str:
    if points is None:
        return "\\question\n\n"
    else:
        return f"\\question[{points}]\n\n"


def render_multiple_choice(q: Dict[str, Any]) -> str:
    s = [question_header(q.get("points"))]
    text = q.get("question", "").strip()
    text = convert_fenced_code(text)
    text = convert_inline_code(text)
    s.append(escape_latex(text) + "\n")

    choices = q.get("choices", [])
    s.append(maybe_multicols_open(len(choices)))
    s.append(render_choices(choices, q.get("correct_choice")))
    s.append(maybe_multicols_close(len(choices)))
    s.append("\n")
    return "".join(s)


def render_fill_in_the_blank(q: Dict[str, Any]) -> str:
    s = [question_header(q.get("points"))]
    base = q.get("question", "").strip()
    expressions = q.get("expressions")

    if expressions:
        s.append("\\begin{multicols}{1}\n\\begin{enumerate}\n")
        for item in expressions:
            if isinstance(item, str):
                line = replace_placeholders_with_fillin(item)
                line = convert_inline_code(line)
                line = escape_latex(line)
                s.append(f"    \n    \item {line}\n")
        s.append("\\end{enumerate}\n\\end{multicols}\n\n")
    else:
        txt = replace_placeholders_with_fillin(base)
        txt = convert_fenced_code(txt)
        txt = convert_inline_code(txt)
        s.append(escape_latex(txt) + "\n\n")
    return "".join(s)


def render_multiple_fill_in(q: Dict[str, Any]) -> str:
    s = [question_header(q.get("points"))]
    text = q.get("question", "").strip()
    text = convert_fenced_code(text)
    text = convert_inline_code(text)
    s.append(escape_latex(text) + "\n\n")

    pairs = q.get("expressions", [])
    s.append("\\begin{multicols}{2}\n\\begin{enumerate}\n")
    for left, ans in pairs:
        left = convert_inline_code(left)
        left = escape_latex(left)
        ans = escape_latex(str(ans))
        s.append(f"    \\item {left} \\hspace{{1em}} \\fillin[{ans}]\n")
    s.append("\\end{enumerate}\n\\end{multicols}\n\n")
    return "".join(s)


def render_short_answer(q: Dict[str, Any]) -> str:
    s = [question_header(q.get("points"))]
    text = q.get("question", "").strip()
    text = convert_fenced_code(text)
    text = convert_inline_code(text)
    s.append(escape_latex(text) + "\n\n")
    s.append("\\fillwithlines{1cm}\n\n")
    if q.get("answer"):
        ans = str(q["answer"]).replace("\n", " ")
        s.append(f"% Expected answer: {ans}\n\n")
    return "".join(s)


def render_question(q: Dict[str, Any]) -> str:
    qtype = q.get("type")
    if qtype == "multiple_choice":
        return render_multiple_choice(q)
    elif qtype == "fill_in_the_blank":
        return render_fill_in_the_blank(q)
    elif qtype == "multiple_fill_in":
        return render_multiple_fill_in(q)
    elif qtype == "short_answer":
        return render_short_answer(q)
    else:
        raise ValueError(f"Unsupported question type: {qtype}")


def render_document(data: Dict[str, Any]) -> str:
    parts: List[str] = [PREAMBLE]

    # Cover
    cover = COVER_TEMPLATE.format(
        title=escape_latex(data.get("title", "")),
        subtitle=escape_latex(data.get("subtitle", "")),
        author=escape_latex(data.get("author", "")),
        department=escape_latex(data.get("department", "")),
        school=escape_latex(data.get("school", "")),
        date=escape_latex(data.get("date", "")),
        directives=render_directives(data.get("directives", [])),
    )
    parts.append(cover)

    # Questions
    for q in data.get("questions", []):
        parts.append(render_question(q))

    parts.append(END_DOC)
    return "".join(parts)


# ------------------------- CLI -------------------------

def main() -> None:
    ap = argparse.ArgumentParser(description="Convert YAML quiz to LaTeX exam (exam class)")
    ap.add_argument("input", type=Path, help="Path to YAML input file")
    ap.add_argument("-o", "--output", type=Path, help="Output .tex file path (default: input with .tex)")
    args = ap.parse_args()

    with args.input.open("r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    tex = render_document(data)

    out = args.output or args.input.with_suffix(".tex")
    out.write_text(tex, encoding="utf-8")
    print(f"Wrote {out}")


if __name__ == "__main__":
    main()
